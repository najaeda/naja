// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SNLIMPLEMENTATION_SNL_FBS_H_
#define FLATBUFFERS_GENERATED_SNLIMPLEMENTATION_SNL_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace SNL {
namespace FBS {

struct DesignID;

struct Instance;
struct InstanceBuilder;

struct DesignImplementation;
struct DesignImplementationBuilder;

struct LibraryImplementation;
struct LibraryImplementationBuilder;

struct DBImplementation;
struct DBImplementationBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) DesignID FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t db_id_;
  int8_t padding0__;
  uint16_t library_id_;
  uint32_t design_id_;

 public:
  DesignID()
      : db_id_(0),
        padding0__(0),
        library_id_(0),
        design_id_(0) {
    (void)padding0__;
  }
  DesignID(int8_t _db_id, uint16_t _library_id, uint32_t _design_id)
      : db_id_(flatbuffers::EndianScalar(_db_id)),
        padding0__(0),
        library_id_(flatbuffers::EndianScalar(_library_id)),
        design_id_(flatbuffers::EndianScalar(_design_id)) {
    (void)padding0__;
  }
  int8_t db_id() const {
    return flatbuffers::EndianScalar(db_id_);
  }
  uint16_t library_id() const {
    return flatbuffers::EndianScalar(library_id_);
  }
  uint32_t design_id() const {
    return flatbuffers::EndianScalar(design_id_);
  }
};
FLATBUFFERS_STRUCT_END(DesignID, 8);

struct Instance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstanceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL = 4
  };
  const SNL::FBS::DesignID *model() const {
    return GetStruct<const SNL::FBS::DesignID *>(VT_MODEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<SNL::FBS::DesignID>(verifier, VT_MODEL, 4) &&
           verifier.EndTable();
  }
};

struct InstanceBuilder {
  typedef Instance Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_model(const SNL::FBS::DesignID *model) {
    fbb_.AddStruct(Instance::VT_MODEL, model);
  }
  explicit InstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Instance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Instance>(end);
    return o;
  }
};

inline flatbuffers::Offset<Instance> CreateInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    const SNL::FBS::DesignID *model = nullptr) {
  InstanceBuilder builder_(_fbb);
  builder_.add_model(model);
  return builder_.Finish();
}

struct DesignImplementation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DesignImplementationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Instance>> *instances() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Instance>> *>(VT_INSTANCES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCES) &&
           verifier.VerifyVector(instances()) &&
           verifier.VerifyVectorOfTables(instances()) &&
           verifier.EndTable();
  }
};

struct DesignImplementationBuilder {
  typedef DesignImplementation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instances(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Instance>>> instances) {
    fbb_.AddOffset(DesignImplementation::VT_INSTANCES, instances);
  }
  explicit DesignImplementationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DesignImplementation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DesignImplementation>(end);
    return o;
  }
};

inline flatbuffers::Offset<DesignImplementation> CreateDesignImplementation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Instance>>> instances = 0) {
  DesignImplementationBuilder builder_(_fbb);
  builder_.add_instances(instances);
  return builder_.Finish();
}

inline flatbuffers::Offset<DesignImplementation> CreateDesignImplementationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SNL::FBS::Instance>> *instances = nullptr) {
  auto instances__ = instances ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::Instance>>(*instances) : 0;
  return SNL::FBS::CreateDesignImplementation(
      _fbb,
      instances__);
}

struct LibraryImplementation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LibraryImplementationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DESIGN_IMPLEMENTATIONS = 6
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignImplementation>> *design_implementations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignImplementation>> *>(VT_DESIGN_IMPLEMENTATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID, 2) &&
           VerifyOffset(verifier, VT_DESIGN_IMPLEMENTATIONS) &&
           verifier.VerifyVector(design_implementations()) &&
           verifier.VerifyVectorOfTables(design_implementations()) &&
           verifier.EndTable();
  }
};

struct LibraryImplementationBuilder {
  typedef LibraryImplementation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(LibraryImplementation::VT_ID, id, 0);
  }
  void add_design_implementations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignImplementation>>> design_implementations) {
    fbb_.AddOffset(LibraryImplementation::VT_DESIGN_IMPLEMENTATIONS, design_implementations);
  }
  explicit LibraryImplementationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LibraryImplementation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LibraryImplementation>(end);
    return o;
  }
};

inline flatbuffers::Offset<LibraryImplementation> CreateLibraryImplementation(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignImplementation>>> design_implementations = 0) {
  LibraryImplementationBuilder builder_(_fbb);
  builder_.add_design_implementations(design_implementations);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<LibraryImplementation> CreateLibraryImplementationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    const std::vector<flatbuffers::Offset<SNL::FBS::DesignImplementation>> *design_implementations = nullptr) {
  auto design_implementations__ = design_implementations ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::DesignImplementation>>(*design_implementations) : 0;
  return SNL::FBS::CreateLibraryImplementation(
      _fbb,
      id,
      design_implementations__);
}

struct DBImplementation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DBImplementationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LIBRARY_IMPLEMENTATIONS = 6
  };
  int8_t id() const {
    return GetField<int8_t>(VT_ID, 1);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::LibraryImplementation>> *library_implementations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::LibraryImplementation>> *>(VT_LIBRARY_IMPLEMENTATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ID, 1) &&
           VerifyOffset(verifier, VT_LIBRARY_IMPLEMENTATIONS) &&
           verifier.VerifyVector(library_implementations()) &&
           verifier.VerifyVectorOfTables(library_implementations()) &&
           verifier.EndTable();
  }
};

struct DBImplementationBuilder {
  typedef DBImplementation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int8_t id) {
    fbb_.AddElement<int8_t>(DBImplementation::VT_ID, id, 1);
  }
  void add_library_implementations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::LibraryImplementation>>> library_implementations) {
    fbb_.AddOffset(DBImplementation::VT_LIBRARY_IMPLEMENTATIONS, library_implementations);
  }
  explicit DBImplementationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DBImplementation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DBImplementation>(end);
    return o;
  }
};

inline flatbuffers::Offset<DBImplementation> CreateDBImplementation(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t id = 1,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::LibraryImplementation>>> library_implementations = 0) {
  DBImplementationBuilder builder_(_fbb);
  builder_.add_library_implementations(library_implementations);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DBImplementation> CreateDBImplementationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t id = 1,
    const std::vector<flatbuffers::Offset<SNL::FBS::LibraryImplementation>> *library_implementations = nullptr) {
  auto library_implementations__ = library_implementations ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::LibraryImplementation>>(*library_implementations) : 0;
  return SNL::FBS::CreateDBImplementation(
      _fbb,
      id,
      library_implementations__);
}

inline const SNL::FBS::DBImplementation *GetDBImplementation(const void *buf) {
  return flatbuffers::GetRoot<SNL::FBS::DBImplementation>(buf);
}

inline const SNL::FBS::DBImplementation *GetSizePrefixedDBImplementation(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SNL::FBS::DBImplementation>(buf);
}

inline bool VerifyDBImplementationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SNL::FBS::DBImplementation>(nullptr);
}

inline bool VerifySizePrefixedDBImplementationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SNL::FBS::DBImplementation>(nullptr);
}

inline void FinishDBImplementationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SNL::FBS::DBImplementation> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDBImplementationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SNL::FBS::DBImplementation> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace FBS
}  // namespace SNL

#endif  // FLATBUFFERS_GENERATED_SNLIMPLEMENTATION_SNL_FBS_H_
