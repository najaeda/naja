// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SNLINTERFACE_SNL_FBS_H_
#define FLATBUFFERS_GENERATED_SNLINTERFACE_SNL_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace SNL {
namespace FBS {

struct ScalarTerm;
struct ScalarTermBuilder;

struct BusTerm;
struct BusTermBuilder;

struct Parameter;
struct ParameterBuilder;

struct DesignInterface;
struct DesignInterfaceBuilder;

struct LibraryInterface;
struct LibraryInterfaceBuilder;

struct DBInterface;
struct DBInterfaceBuilder;

enum TermDirection : int8_t {
  TermDirection_Input = 0,
  TermDirection_Output = 1,
  TermDirection_InOut = 2,
  TermDirection_MIN = TermDirection_Input,
  TermDirection_MAX = TermDirection_InOut
};

inline const TermDirection (&EnumValuesTermDirection())[3] {
  static const TermDirection values[] = {
    TermDirection_Input,
    TermDirection_Output,
    TermDirection_InOut
  };
  return values;
}

inline const char * const *EnumNamesTermDirection() {
  static const char * const names[4] = {
    "Input",
    "Output",
    "InOut",
    nullptr
  };
  return names;
}

inline const char *EnumNameTermDirection(TermDirection e) {
  if (flatbuffers::IsOutRange(e, TermDirection_Input, TermDirection_InOut)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTermDirection()[index];
}

enum Term : uint8_t {
  Term_NONE = 0,
  Term_ScalarTerm = 1,
  Term_BusTerm = 2,
  Term_MIN = Term_NONE,
  Term_MAX = Term_BusTerm
};

inline const Term (&EnumValuesTerm())[3] {
  static const Term values[] = {
    Term_NONE,
    Term_ScalarTerm,
    Term_BusTerm
  };
  return values;
}

inline const char * const *EnumNamesTerm() {
  static const char * const names[4] = {
    "NONE",
    "ScalarTerm",
    "BusTerm",
    nullptr
  };
  return names;
}

inline const char *EnumNameTerm(Term e) {
  if (flatbuffers::IsOutRange(e, Term_NONE, Term_BusTerm)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTerm()[index];
}

template<typename T> struct TermTraits {
  static const Term enum_value = Term_NONE;
};

template<> struct TermTraits<SNL::FBS::ScalarTerm> {
  static const Term enum_value = Term_ScalarTerm;
};

template<> struct TermTraits<SNL::FBS::BusTerm> {
  static const Term enum_value = Term_BusTerm;
};

bool VerifyTerm(flatbuffers::Verifier &verifier, const void *obj, Term type);
bool VerifyTermVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum DesignType : int8_t {
  DesignType_Standard = 0,
  DesignType_Blackbox = 1,
  DesignType_Primitive = 2,
  DesignType_MIN = DesignType_Standard,
  DesignType_MAX = DesignType_Primitive
};

inline const DesignType (&EnumValuesDesignType())[3] {
  static const DesignType values[] = {
    DesignType_Standard,
    DesignType_Blackbox,
    DesignType_Primitive
  };
  return values;
}

inline const char * const *EnumNamesDesignType() {
  static const char * const names[4] = {
    "Standard",
    "Blackbox",
    "Primitive",
    nullptr
  };
  return names;
}

inline const char *EnumNameDesignType(DesignType e) {
  if (flatbuffers::IsOutRange(e, DesignType_Standard, DesignType_Primitive)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDesignType()[index];
}

enum LibraryType : int8_t {
  LibraryType_Standard = 0,
  LibraryType_Primitives = 1,
  LibraryType_MIN = LibraryType_Standard,
  LibraryType_MAX = LibraryType_Primitives
};

inline const LibraryType (&EnumValuesLibraryType())[2] {
  static const LibraryType values[] = {
    LibraryType_Standard,
    LibraryType_Primitives
  };
  return values;
}

inline const char * const *EnumNamesLibraryType() {
  static const char * const names[3] = {
    "Standard",
    "Primitives",
    nullptr
  };
  return names;
}

inline const char *EnumNameLibraryType(LibraryType e) {
  if (flatbuffers::IsOutRange(e, LibraryType_Standard, LibraryType_Primitives)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLibraryType()[index];
}

struct ScalarTerm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarTermBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_DIRECTION = 8
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  SNL::FBS::TermDirection direction() const {
    return static_cast<SNL::FBS::TermDirection>(GetField<int8_t>(VT_DIRECTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_DIRECTION, 1) &&
           verifier.EndTable();
  }
};

struct ScalarTermBuilder {
  typedef ScalarTerm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(ScalarTerm::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ScalarTerm::VT_NAME, name);
  }
  void add_direction(SNL::FBS::TermDirection direction) {
    fbb_.AddElement<int8_t>(ScalarTerm::VT_DIRECTION, static_cast<int8_t>(direction), 0);
  }
  explicit ScalarTermBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarTerm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarTerm>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarTerm> CreateScalarTerm(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    SNL::FBS::TermDirection direction = SNL::FBS::TermDirection_Input) {
  ScalarTermBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_direction(direction);
  return builder_.Finish();
}

inline flatbuffers::Offset<ScalarTerm> CreateScalarTermDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    SNL::FBS::TermDirection direction = SNL::FBS::TermDirection_Input) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return SNL::FBS::CreateScalarTerm(
      _fbb,
      id,
      name__,
      direction);
}

struct BusTerm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BusTermBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_DIRECTION = 8,
    VT_MSB = 10,
    VT_LSB = 12
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  SNL::FBS::TermDirection direction() const {
    return static_cast<SNL::FBS::TermDirection>(GetField<int8_t>(VT_DIRECTION, 0));
  }
  int32_t msb() const {
    return GetField<int32_t>(VT_MSB, 0);
  }
  int32_t lsb() const {
    return GetField<int32_t>(VT_LSB, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_DIRECTION, 1) &&
           VerifyField<int32_t>(verifier, VT_MSB, 4) &&
           VerifyField<int32_t>(verifier, VT_LSB, 4) &&
           verifier.EndTable();
  }
};

struct BusTermBuilder {
  typedef BusTerm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(BusTerm::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(BusTerm::VT_NAME, name);
  }
  void add_direction(SNL::FBS::TermDirection direction) {
    fbb_.AddElement<int8_t>(BusTerm::VT_DIRECTION, static_cast<int8_t>(direction), 0);
  }
  void add_msb(int32_t msb) {
    fbb_.AddElement<int32_t>(BusTerm::VT_MSB, msb, 0);
  }
  void add_lsb(int32_t lsb) {
    fbb_.AddElement<int32_t>(BusTerm::VT_LSB, lsb, 0);
  }
  explicit BusTermBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BusTerm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BusTerm>(end);
    return o;
  }
};

inline flatbuffers::Offset<BusTerm> CreateBusTerm(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    SNL::FBS::TermDirection direction = SNL::FBS::TermDirection_Input,
    int32_t msb = 0,
    int32_t lsb = 0) {
  BusTermBuilder builder_(_fbb);
  builder_.add_lsb(lsb);
  builder_.add_msb(msb);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_direction(direction);
  return builder_.Finish();
}

inline flatbuffers::Offset<BusTerm> CreateBusTermDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    SNL::FBS::TermDirection direction = SNL::FBS::TermDirection_Input,
    int32_t msb = 0,
    int32_t lsb = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return SNL::FBS::CreateBusTerm(
      _fbb,
      id,
      name__,
      direction,
      msb,
      lsb);
}

struct Parameter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ParameterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct ParameterBuilder {
  typedef Parameter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Parameter::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(Parameter::VT_VALUE, value);
  }
  explicit ParameterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Parameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Parameter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Parameter> CreateParameter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  ParameterBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Parameter> CreateParameterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *value = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return SNL::FBS::CreateParameter(
      _fbb,
      name__,
      value__);
}

struct DesignInterface FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DesignInterfaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TYPE = 8,
    VT_PARAMETERS = 10,
    VT_TERMS_TYPE = 12,
    VT_TERMS = 14
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  SNL::FBS::DesignType type() const {
    return static_cast<SNL::FBS::DesignType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Parameter>> *parameters() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Parameter>> *>(VT_PARAMETERS);
  }
  const flatbuffers::Vector<uint8_t> *terms_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TERMS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *terms() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_TERMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           VerifyOffset(verifier, VT_TERMS_TYPE) &&
           verifier.VerifyVector(terms_type()) &&
           VerifyOffset(verifier, VT_TERMS) &&
           verifier.VerifyVector(terms()) &&
           VerifyTermVector(verifier, terms(), terms_type()) &&
           verifier.EndTable();
  }
};

struct DesignInterfaceBuilder {
  typedef DesignInterface Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(DesignInterface::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DesignInterface::VT_NAME, name);
  }
  void add_type(SNL::FBS::DesignType type) {
    fbb_.AddElement<int8_t>(DesignInterface::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_parameters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Parameter>>> parameters) {
    fbb_.AddOffset(DesignInterface::VT_PARAMETERS, parameters);
  }
  void add_terms_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> terms_type) {
    fbb_.AddOffset(DesignInterface::VT_TERMS_TYPE, terms_type);
  }
  void add_terms(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> terms) {
    fbb_.AddOffset(DesignInterface::VT_TERMS, terms);
  }
  explicit DesignInterfaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DesignInterface> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DesignInterface>(end);
    return o;
  }
};

inline flatbuffers::Offset<DesignInterface> CreateDesignInterface(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    SNL::FBS::DesignType type = SNL::FBS::DesignType_Standard,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Parameter>>> parameters = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> terms_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> terms = 0) {
  DesignInterfaceBuilder builder_(_fbb);
  builder_.add_terms(terms);
  builder_.add_terms_type(terms_type);
  builder_.add_parameters(parameters);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DesignInterface> CreateDesignInterfaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    SNL::FBS::DesignType type = SNL::FBS::DesignType_Standard,
    const std::vector<flatbuffers::Offset<SNL::FBS::Parameter>> *parameters = nullptr,
    const std::vector<uint8_t> *terms_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *terms = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::Parameter>>(*parameters) : 0;
  auto terms_type__ = terms_type ? _fbb.CreateVector<uint8_t>(*terms_type) : 0;
  auto terms__ = terms ? _fbb.CreateVector<flatbuffers::Offset<void>>(*terms) : 0;
  return SNL::FBS::CreateDesignInterface(
      _fbb,
      id,
      name__,
      type,
      parameters__,
      terms_type__,
      terms__);
}

struct LibraryInterface FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LibraryInterfaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TYPE = 8,
    VT_LIBRARY_INTERFACES = 10,
    VT_DESIGN_INTERFACES = 12
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  SNL::FBS::LibraryType type() const {
    return static_cast<SNL::FBS::LibraryType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::LibraryInterface>> *library_interfaces() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::LibraryInterface>> *>(VT_LIBRARY_INTERFACES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignInterface>> *design_interfaces() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignInterface>> *>(VT_DESIGN_INTERFACES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID, 2) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_LIBRARY_INTERFACES) &&
           verifier.VerifyVector(library_interfaces()) &&
           verifier.VerifyVectorOfTables(library_interfaces()) &&
           VerifyOffset(verifier, VT_DESIGN_INTERFACES) &&
           verifier.VerifyVector(design_interfaces()) &&
           verifier.VerifyVectorOfTables(design_interfaces()) &&
           verifier.EndTable();
  }
};

struct LibraryInterfaceBuilder {
  typedef LibraryInterface Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(LibraryInterface::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(LibraryInterface::VT_NAME, name);
  }
  void add_type(SNL::FBS::LibraryType type) {
    fbb_.AddElement<int8_t>(LibraryInterface::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_library_interfaces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::LibraryInterface>>> library_interfaces) {
    fbb_.AddOffset(LibraryInterface::VT_LIBRARY_INTERFACES, library_interfaces);
  }
  void add_design_interfaces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignInterface>>> design_interfaces) {
    fbb_.AddOffset(LibraryInterface::VT_DESIGN_INTERFACES, design_interfaces);
  }
  explicit LibraryInterfaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LibraryInterface> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LibraryInterface>(end);
    return o;
  }
};

inline flatbuffers::Offset<LibraryInterface> CreateLibraryInterface(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    SNL::FBS::LibraryType type = SNL::FBS::LibraryType_Standard,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::LibraryInterface>>> library_interfaces = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignInterface>>> design_interfaces = 0) {
  LibraryInterfaceBuilder builder_(_fbb);
  builder_.add_design_interfaces(design_interfaces);
  builder_.add_library_interfaces(library_interfaces);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<LibraryInterface> CreateLibraryInterfaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    const char *name = nullptr,
    SNL::FBS::LibraryType type = SNL::FBS::LibraryType_Standard,
    const std::vector<flatbuffers::Offset<SNL::FBS::LibraryInterface>> *library_interfaces = nullptr,
    const std::vector<flatbuffers::Offset<SNL::FBS::DesignInterface>> *design_interfaces = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto library_interfaces__ = library_interfaces ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::LibraryInterface>>(*library_interfaces) : 0;
  auto design_interfaces__ = design_interfaces ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::DesignInterface>>(*design_interfaces) : 0;
  return SNL::FBS::CreateLibraryInterface(
      _fbb,
      id,
      name__,
      type,
      library_interfaces__,
      design_interfaces__);
}

struct DBInterface FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DBInterfaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LIBRARY_INTERFACES = 6
  };
  int8_t id() const {
    return GetField<int8_t>(VT_ID, 1);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::LibraryInterface>> *library_interfaces() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::LibraryInterface>> *>(VT_LIBRARY_INTERFACES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ID, 1) &&
           VerifyOffset(verifier, VT_LIBRARY_INTERFACES) &&
           verifier.VerifyVector(library_interfaces()) &&
           verifier.VerifyVectorOfTables(library_interfaces()) &&
           verifier.EndTable();
  }
};

struct DBInterfaceBuilder {
  typedef DBInterface Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int8_t id) {
    fbb_.AddElement<int8_t>(DBInterface::VT_ID, id, 1);
  }
  void add_library_interfaces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::LibraryInterface>>> library_interfaces) {
    fbb_.AddOffset(DBInterface::VT_LIBRARY_INTERFACES, library_interfaces);
  }
  explicit DBInterfaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DBInterface> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DBInterface>(end);
    return o;
  }
};

inline flatbuffers::Offset<DBInterface> CreateDBInterface(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t id = 1,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::LibraryInterface>>> library_interfaces = 0) {
  DBInterfaceBuilder builder_(_fbb);
  builder_.add_library_interfaces(library_interfaces);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DBInterface> CreateDBInterfaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t id = 1,
    const std::vector<flatbuffers::Offset<SNL::FBS::LibraryInterface>> *library_interfaces = nullptr) {
  auto library_interfaces__ = library_interfaces ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::LibraryInterface>>(*library_interfaces) : 0;
  return SNL::FBS::CreateDBInterface(
      _fbb,
      id,
      library_interfaces__);
}

inline bool VerifyTerm(flatbuffers::Verifier &verifier, const void *obj, Term type) {
  switch (type) {
    case Term_NONE: {
      return true;
    }
    case Term_ScalarTerm: {
      auto ptr = reinterpret_cast<const SNL::FBS::ScalarTerm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Term_BusTerm: {
      auto ptr = reinterpret_cast<const SNL::FBS::BusTerm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTermVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTerm(
        verifier,  values->Get(i), types->GetEnum<Term>(i))) {
      return false;
    }
  }
  return true;
}

inline const SNL::FBS::DBInterface *GetDBInterface(const void *buf) {
  return flatbuffers::GetRoot<SNL::FBS::DBInterface>(buf);
}

inline const SNL::FBS::DBInterface *GetSizePrefixedDBInterface(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SNL::FBS::DBInterface>(buf);
}

inline bool VerifyDBInterfaceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SNL::FBS::DBInterface>(nullptr);
}

inline bool VerifySizePrefixedDBInterfaceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SNL::FBS::DBInterface>(nullptr);
}

inline void FinishDBInterfaceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SNL::FBS::DBInterface> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDBInterfaceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SNL::FBS::DBInterface> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace FBS
}  // namespace SNL

#endif  // FLATBUFFERS_GENERATED_SNLINTERFACE_SNL_FBS_H_
