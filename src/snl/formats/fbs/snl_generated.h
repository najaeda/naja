// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SNL_SNL_FBS_H_
#define FLATBUFFERS_GENERATED_SNL_SNL_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace SNL {
namespace FBS {

struct ScalarTerm;
struct ScalarTermBuilder;

struct BusTerm;
struct BusTermBuilder;

struct Design;
struct DesignBuilder;

struct Library;
struct LibraryBuilder;

struct DB;
struct DBBuilder;

enum TermDirection : int8_t {
  TermDirection_Input = 0,
  TermDirection_Output = 1,
  TermDirection_InOut = 2,
  TermDirection_MIN = TermDirection_Input,
  TermDirection_MAX = TermDirection_InOut
};

inline const TermDirection (&EnumValuesTermDirection())[3] {
  static const TermDirection values[] = {
    TermDirection_Input,
    TermDirection_Output,
    TermDirection_InOut
  };
  return values;
}

inline const char * const *EnumNamesTermDirection() {
  static const char * const names[4] = {
    "Input",
    "Output",
    "InOut",
    nullptr
  };
  return names;
}

inline const char *EnumNameTermDirection(TermDirection e) {
  if (flatbuffers::IsOutRange(e, TermDirection_Input, TermDirection_InOut)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTermDirection()[index];
}

enum Term : uint8_t {
  Term_NONE = 0,
  Term_ScalarTerm = 1,
  Term_BusTerm = 2,
  Term_MIN = Term_NONE,
  Term_MAX = Term_BusTerm
};

inline const Term (&EnumValuesTerm())[3] {
  static const Term values[] = {
    Term_NONE,
    Term_ScalarTerm,
    Term_BusTerm
  };
  return values;
}

inline const char * const *EnumNamesTerm() {
  static const char * const names[4] = {
    "NONE",
    "ScalarTerm",
    "BusTerm",
    nullptr
  };
  return names;
}

inline const char *EnumNameTerm(Term e) {
  if (flatbuffers::IsOutRange(e, Term_NONE, Term_BusTerm)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTerm()[index];
}

template<typename T> struct TermTraits {
  static const Term enum_value = Term_NONE;
};

template<> struct TermTraits<SNL::FBS::ScalarTerm> {
  static const Term enum_value = Term_ScalarTerm;
};

template<> struct TermTraits<SNL::FBS::BusTerm> {
  static const Term enum_value = Term_BusTerm;
};

bool VerifyTerm(flatbuffers::Verifier &verifier, const void *obj, Term type);
bool VerifyTermVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum DesignType : int8_t {
  DesignType_Standard = 0,
  DesignType_Blackbox = 1,
  DesignType_Primitive = 2,
  DesignType_MIN = DesignType_Standard,
  DesignType_MAX = DesignType_Primitive
};

inline const DesignType (&EnumValuesDesignType())[3] {
  static const DesignType values[] = {
    DesignType_Standard,
    DesignType_Blackbox,
    DesignType_Primitive
  };
  return values;
}

inline const char * const *EnumNamesDesignType() {
  static const char * const names[4] = {
    "Standard",
    "Blackbox",
    "Primitive",
    nullptr
  };
  return names;
}

inline const char *EnumNameDesignType(DesignType e) {
  if (flatbuffers::IsOutRange(e, DesignType_Standard, DesignType_Primitive)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDesignType()[index];
}

enum LibraryType : int8_t {
  LibraryType_Standard = 0,
  LibraryType_Primitives = 1,
  LibraryType_MIN = LibraryType_Standard,
  LibraryType_MAX = LibraryType_Primitives
};

inline const LibraryType (&EnumValuesLibraryType())[2] {
  static const LibraryType values[] = {
    LibraryType_Standard,
    LibraryType_Primitives
  };
  return values;
}

inline const char * const *EnumNamesLibraryType() {
  static const char * const names[3] = {
    "Standard",
    "Primitives",
    nullptr
  };
  return names;
}

inline const char *EnumNameLibraryType(LibraryType e) {
  if (flatbuffers::IsOutRange(e, LibraryType_Standard, LibraryType_Primitives)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLibraryType()[index];
}

struct ScalarTerm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarTermBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_DIRECTION = 8
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  SNL::FBS::TermDirection direction() const {
    return static_cast<SNL::FBS::TermDirection>(GetField<int8_t>(VT_DIRECTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_DIRECTION, 1) &&
           verifier.EndTable();
  }
};

struct ScalarTermBuilder {
  typedef ScalarTerm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(ScalarTerm::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ScalarTerm::VT_NAME, name);
  }
  void add_direction(SNL::FBS::TermDirection direction) {
    fbb_.AddElement<int8_t>(ScalarTerm::VT_DIRECTION, static_cast<int8_t>(direction), 0);
  }
  explicit ScalarTermBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarTerm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarTerm>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarTerm> CreateScalarTerm(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    SNL::FBS::TermDirection direction = SNL::FBS::TermDirection_Input) {
  ScalarTermBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_direction(direction);
  return builder_.Finish();
}

inline flatbuffers::Offset<ScalarTerm> CreateScalarTermDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    SNL::FBS::TermDirection direction = SNL::FBS::TermDirection_Input) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return SNL::FBS::CreateScalarTerm(
      _fbb,
      id,
      name__,
      direction);
}

struct BusTerm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BusTermBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_DIRECTION = 8
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  SNL::FBS::TermDirection direction() const {
    return static_cast<SNL::FBS::TermDirection>(GetField<int8_t>(VT_DIRECTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_DIRECTION, 1) &&
           verifier.EndTable();
  }
};

struct BusTermBuilder {
  typedef BusTerm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(BusTerm::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(BusTerm::VT_NAME, name);
  }
  void add_direction(SNL::FBS::TermDirection direction) {
    fbb_.AddElement<int8_t>(BusTerm::VT_DIRECTION, static_cast<int8_t>(direction), 0);
  }
  explicit BusTermBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BusTerm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BusTerm>(end);
    return o;
  }
};

inline flatbuffers::Offset<BusTerm> CreateBusTerm(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    SNL::FBS::TermDirection direction = SNL::FBS::TermDirection_Input) {
  BusTermBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_direction(direction);
  return builder_.Finish();
}

inline flatbuffers::Offset<BusTerm> CreateBusTermDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    SNL::FBS::TermDirection direction = SNL::FBS::TermDirection_Input) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return SNL::FBS::CreateBusTerm(
      _fbb,
      id,
      name__,
      direction);
}

struct Design FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DesignBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TYPE = 8,
    VT_TERMS_TYPE = 10,
    VT_TERMS = 12
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  SNL::FBS::DesignType type() const {
    return static_cast<SNL::FBS::DesignType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<uint8_t> *terms_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TERMS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *terms() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_TERMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_TERMS_TYPE) &&
           verifier.VerifyVector(terms_type()) &&
           VerifyOffset(verifier, VT_TERMS) &&
           verifier.VerifyVector(terms()) &&
           VerifyTermVector(verifier, terms(), terms_type()) &&
           verifier.EndTable();
  }
};

struct DesignBuilder {
  typedef Design Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Design::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Design::VT_NAME, name);
  }
  void add_type(SNL::FBS::DesignType type) {
    fbb_.AddElement<int8_t>(Design::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_terms_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> terms_type) {
    fbb_.AddOffset(Design::VT_TERMS_TYPE, terms_type);
  }
  void add_terms(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> terms) {
    fbb_.AddOffset(Design::VT_TERMS, terms);
  }
  explicit DesignBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Design> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Design>(end);
    return o;
  }
};

inline flatbuffers::Offset<Design> CreateDesign(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    SNL::FBS::DesignType type = SNL::FBS::DesignType_Standard,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> terms_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> terms = 0) {
  DesignBuilder builder_(_fbb);
  builder_.add_terms(terms);
  builder_.add_terms_type(terms_type);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Design> CreateDesignDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    SNL::FBS::DesignType type = SNL::FBS::DesignType_Standard,
    const std::vector<uint8_t> *terms_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *terms = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto terms_type__ = terms_type ? _fbb.CreateVector<uint8_t>(*terms_type) : 0;
  auto terms__ = terms ? _fbb.CreateVector<flatbuffers::Offset<void>>(*terms) : 0;
  return SNL::FBS::CreateDesign(
      _fbb,
      id,
      name__,
      type,
      terms_type__,
      terms__);
}

struct Library FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LibraryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TYPE = 8,
    VT_LIBRARIES = 10,
    VT_DESIGNS = 12
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  SNL::FBS::LibraryType type() const {
    return static_cast<SNL::FBS::LibraryType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>> *libraries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>> *>(VT_LIBRARIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Design>> *designs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Design>> *>(VT_DESIGNS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID, 2) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_LIBRARIES) &&
           verifier.VerifyVector(libraries()) &&
           verifier.VerifyVectorOfTables(libraries()) &&
           VerifyOffset(verifier, VT_DESIGNS) &&
           verifier.VerifyVector(designs()) &&
           verifier.VerifyVectorOfTables(designs()) &&
           verifier.EndTable();
  }
};

struct LibraryBuilder {
  typedef Library Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Library::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Library::VT_NAME, name);
  }
  void add_type(SNL::FBS::LibraryType type) {
    fbb_.AddElement<int8_t>(Library::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_libraries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>>> libraries) {
    fbb_.AddOffset(Library::VT_LIBRARIES, libraries);
  }
  void add_designs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Design>>> designs) {
    fbb_.AddOffset(Library::VT_DESIGNS, designs);
  }
  explicit LibraryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Library> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Library>(end);
    return o;
  }
};

inline flatbuffers::Offset<Library> CreateLibrary(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    SNL::FBS::LibraryType type = SNL::FBS::LibraryType_Standard,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>>> libraries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Design>>> designs = 0) {
  LibraryBuilder builder_(_fbb);
  builder_.add_designs(designs);
  builder_.add_libraries(libraries);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Library> CreateLibraryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    const char *name = nullptr,
    SNL::FBS::LibraryType type = SNL::FBS::LibraryType_Standard,
    const std::vector<flatbuffers::Offset<SNL::FBS::Library>> *libraries = nullptr,
    const std::vector<flatbuffers::Offset<SNL::FBS::Design>> *designs = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto libraries__ = libraries ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::Library>>(*libraries) : 0;
  auto designs__ = designs ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::Design>>(*designs) : 0;
  return SNL::FBS::CreateLibrary(
      _fbb,
      id,
      name__,
      type,
      libraries__,
      designs__);
}

struct DB FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LIBRARIES = 6
  };
  int8_t id() const {
    return GetField<int8_t>(VT_ID, 1);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>> *libraries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>> *>(VT_LIBRARIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ID, 1) &&
           VerifyOffset(verifier, VT_LIBRARIES) &&
           verifier.VerifyVector(libraries()) &&
           verifier.VerifyVectorOfTables(libraries()) &&
           verifier.EndTable();
  }
};

struct DBBuilder {
  typedef DB Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int8_t id) {
    fbb_.AddElement<int8_t>(DB::VT_ID, id, 1);
  }
  void add_libraries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>>> libraries) {
    fbb_.AddOffset(DB::VT_LIBRARIES, libraries);
  }
  explicit DBBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DB>(end);
    return o;
  }
};

inline flatbuffers::Offset<DB> CreateDB(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t id = 1,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>>> libraries = 0) {
  DBBuilder builder_(_fbb);
  builder_.add_libraries(libraries);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DB> CreateDBDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t id = 1,
    const std::vector<flatbuffers::Offset<SNL::FBS::Library>> *libraries = nullptr) {
  auto libraries__ = libraries ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::Library>>(*libraries) : 0;
  return SNL::FBS::CreateDB(
      _fbb,
      id,
      libraries__);
}

inline bool VerifyTerm(flatbuffers::Verifier &verifier, const void *obj, Term type) {
  switch (type) {
    case Term_NONE: {
      return true;
    }
    case Term_ScalarTerm: {
      auto ptr = reinterpret_cast<const SNL::FBS::ScalarTerm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Term_BusTerm: {
      auto ptr = reinterpret_cast<const SNL::FBS::BusTerm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTermVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTerm(
        verifier,  values->Get(i), types->GetEnum<Term>(i))) {
      return false;
    }
  }
  return true;
}

inline const SNL::FBS::DB *GetDB(const void *buf) {
  return flatbuffers::GetRoot<SNL::FBS::DB>(buf);
}

inline const SNL::FBS::DB *GetSizePrefixedDB(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SNL::FBS::DB>(buf);
}

inline bool VerifyDBBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SNL::FBS::DB>(nullptr);
}

inline bool VerifySizePrefixedDBBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SNL::FBS::DB>(nullptr);
}

inline void FinishDBBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SNL::FBS::DB> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDBBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SNL::FBS::DB> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace FBS
}  // namespace SNL

#endif  // FLATBUFFERS_GENERATED_SNL_SNL_FBS_H_
