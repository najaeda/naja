// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SNL_SNL_FBS_H_
#define FLATBUFFERS_GENERATED_SNL_SNL_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace SNL {
namespace FBS {

struct ScalarTerm;
struct ScalarTermBuilder;

struct BusTerm;
struct BusTermBuilder;

struct DesignID;

struct Instance;
struct InstanceBuilder;

struct DesignInterface;
struct DesignInterfaceBuilder;

struct DesignImplementation;
struct DesignImplementationBuilder;

struct Library;
struct LibraryBuilder;

struct DB;
struct DBBuilder;

enum TermDirection : int8_t {
  TermDirection_Input = 0,
  TermDirection_Output = 1,
  TermDirection_InOut = 2,
  TermDirection_MIN = TermDirection_Input,
  TermDirection_MAX = TermDirection_InOut
};

inline const TermDirection (&EnumValuesTermDirection())[3] {
  static const TermDirection values[] = {
    TermDirection_Input,
    TermDirection_Output,
    TermDirection_InOut
  };
  return values;
}

inline const char * const *EnumNamesTermDirection() {
  static const char * const names[4] = {
    "Input",
    "Output",
    "InOut",
    nullptr
  };
  return names;
}

inline const char *EnumNameTermDirection(TermDirection e) {
  if (flatbuffers::IsOutRange(e, TermDirection_Input, TermDirection_InOut)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTermDirection()[index];
}

enum Term : uint8_t {
  Term_NONE = 0,
  Term_ScalarTerm = 1,
  Term_BusTerm = 2,
  Term_MIN = Term_NONE,
  Term_MAX = Term_BusTerm
};

inline const Term (&EnumValuesTerm())[3] {
  static const Term values[] = {
    Term_NONE,
    Term_ScalarTerm,
    Term_BusTerm
  };
  return values;
}

inline const char * const *EnumNamesTerm() {
  static const char * const names[4] = {
    "NONE",
    "ScalarTerm",
    "BusTerm",
    nullptr
  };
  return names;
}

inline const char *EnumNameTerm(Term e) {
  if (flatbuffers::IsOutRange(e, Term_NONE, Term_BusTerm)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTerm()[index];
}

template<typename T> struct TermTraits {
  static const Term enum_value = Term_NONE;
};

template<> struct TermTraits<SNL::FBS::ScalarTerm> {
  static const Term enum_value = Term_ScalarTerm;
};

template<> struct TermTraits<SNL::FBS::BusTerm> {
  static const Term enum_value = Term_BusTerm;
};

bool VerifyTerm(flatbuffers::Verifier &verifier, const void *obj, Term type);
bool VerifyTermVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum DesignType : int8_t {
  DesignType_Standard = 0,
  DesignType_Blackbox = 1,
  DesignType_Primitive = 2,
  DesignType_MIN = DesignType_Standard,
  DesignType_MAX = DesignType_Primitive
};

inline const DesignType (&EnumValuesDesignType())[3] {
  static const DesignType values[] = {
    DesignType_Standard,
    DesignType_Blackbox,
    DesignType_Primitive
  };
  return values;
}

inline const char * const *EnumNamesDesignType() {
  static const char * const names[4] = {
    "Standard",
    "Blackbox",
    "Primitive",
    nullptr
  };
  return names;
}

inline const char *EnumNameDesignType(DesignType e) {
  if (flatbuffers::IsOutRange(e, DesignType_Standard, DesignType_Primitive)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDesignType()[index];
}

enum LibraryType : int8_t {
  LibraryType_Standard = 0,
  LibraryType_Primitives = 1,
  LibraryType_MIN = LibraryType_Standard,
  LibraryType_MAX = LibraryType_Primitives
};

inline const LibraryType (&EnumValuesLibraryType())[2] {
  static const LibraryType values[] = {
    LibraryType_Standard,
    LibraryType_Primitives
  };
  return values;
}

inline const char * const *EnumNamesLibraryType() {
  static const char * const names[3] = {
    "Standard",
    "Primitives",
    nullptr
  };
  return names;
}

inline const char *EnumNameLibraryType(LibraryType e) {
  if (flatbuffers::IsOutRange(e, LibraryType_Standard, LibraryType_Primitives)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLibraryType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) DesignID FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t db_id_;
  int8_t padding0__;
  uint16_t library_id_;
  uint32_t design_id_;

 public:
  DesignID()
      : db_id_(0),
        padding0__(0),
        library_id_(0),
        design_id_(0) {
    (void)padding0__;
  }
  DesignID(int8_t _db_id, uint16_t _library_id, uint32_t _design_id)
      : db_id_(flatbuffers::EndianScalar(_db_id)),
        padding0__(0),
        library_id_(flatbuffers::EndianScalar(_library_id)),
        design_id_(flatbuffers::EndianScalar(_design_id)) {
    (void)padding0__;
  }
  int8_t db_id() const {
    return flatbuffers::EndianScalar(db_id_);
  }
  uint16_t library_id() const {
    return flatbuffers::EndianScalar(library_id_);
  }
  uint32_t design_id() const {
    return flatbuffers::EndianScalar(design_id_);
  }
};
FLATBUFFERS_STRUCT_END(DesignID, 8);

struct ScalarTerm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarTermBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_DIRECTION = 8
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  SNL::FBS::TermDirection direction() const {
    return static_cast<SNL::FBS::TermDirection>(GetField<int8_t>(VT_DIRECTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_DIRECTION, 1) &&
           verifier.EndTable();
  }
};

struct ScalarTermBuilder {
  typedef ScalarTerm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(ScalarTerm::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ScalarTerm::VT_NAME, name);
  }
  void add_direction(SNL::FBS::TermDirection direction) {
    fbb_.AddElement<int8_t>(ScalarTerm::VT_DIRECTION, static_cast<int8_t>(direction), 0);
  }
  explicit ScalarTermBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScalarTerm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarTerm>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarTerm> CreateScalarTerm(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    SNL::FBS::TermDirection direction = SNL::FBS::TermDirection_Input) {
  ScalarTermBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_direction(direction);
  return builder_.Finish();
}

inline flatbuffers::Offset<ScalarTerm> CreateScalarTermDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    SNL::FBS::TermDirection direction = SNL::FBS::TermDirection_Input) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return SNL::FBS::CreateScalarTerm(
      _fbb,
      id,
      name__,
      direction);
}

struct BusTerm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BusTermBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_DIRECTION = 8,
    VT_MSB = 10,
    VT_LSB = 12
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  SNL::FBS::TermDirection direction() const {
    return static_cast<SNL::FBS::TermDirection>(GetField<int8_t>(VT_DIRECTION, 0));
  }
  int32_t msb() const {
    return GetField<int32_t>(VT_MSB, 0);
  }
  int32_t lsb() const {
    return GetField<int32_t>(VT_LSB, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_DIRECTION, 1) &&
           VerifyField<int32_t>(verifier, VT_MSB, 4) &&
           VerifyField<int32_t>(verifier, VT_LSB, 4) &&
           verifier.EndTable();
  }
};

struct BusTermBuilder {
  typedef BusTerm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(BusTerm::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(BusTerm::VT_NAME, name);
  }
  void add_direction(SNL::FBS::TermDirection direction) {
    fbb_.AddElement<int8_t>(BusTerm::VT_DIRECTION, static_cast<int8_t>(direction), 0);
  }
  void add_msb(int32_t msb) {
    fbb_.AddElement<int32_t>(BusTerm::VT_MSB, msb, 0);
  }
  void add_lsb(int32_t lsb) {
    fbb_.AddElement<int32_t>(BusTerm::VT_LSB, lsb, 0);
  }
  explicit BusTermBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BusTerm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BusTerm>(end);
    return o;
  }
};

inline flatbuffers::Offset<BusTerm> CreateBusTerm(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    SNL::FBS::TermDirection direction = SNL::FBS::TermDirection_Input,
    int32_t msb = 0,
    int32_t lsb = 0) {
  BusTermBuilder builder_(_fbb);
  builder_.add_lsb(lsb);
  builder_.add_msb(msb);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_direction(direction);
  return builder_.Finish();
}

inline flatbuffers::Offset<BusTerm> CreateBusTermDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    SNL::FBS::TermDirection direction = SNL::FBS::TermDirection_Input,
    int32_t msb = 0,
    int32_t lsb = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return SNL::FBS::CreateBusTerm(
      _fbb,
      id,
      name__,
      direction,
      msb,
      lsb);
}

struct Instance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstanceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL = 4
  };
  const SNL::FBS::DesignID *model() const {
    return GetStruct<const SNL::FBS::DesignID *>(VT_MODEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<SNL::FBS::DesignID>(verifier, VT_MODEL, 4) &&
           verifier.EndTable();
  }
};

struct InstanceBuilder {
  typedef Instance Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_model(const SNL::FBS::DesignID *model) {
    fbb_.AddStruct(Instance::VT_MODEL, model);
  }
  explicit InstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Instance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Instance>(end);
    return o;
  }
};

inline flatbuffers::Offset<Instance> CreateInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    const SNL::FBS::DesignID *model = nullptr) {
  InstanceBuilder builder_(_fbb);
  builder_.add_model(model);
  return builder_.Finish();
}

struct DesignInterface FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DesignInterfaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TYPE = 8,
    VT_TERMS_TYPE = 10,
    VT_TERMS = 12
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  SNL::FBS::DesignType type() const {
    return static_cast<SNL::FBS::DesignType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<uint8_t> *terms_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TERMS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *terms() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_TERMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_TERMS_TYPE) &&
           verifier.VerifyVector(terms_type()) &&
           VerifyOffset(verifier, VT_TERMS) &&
           verifier.VerifyVector(terms()) &&
           VerifyTermVector(verifier, terms(), terms_type()) &&
           verifier.EndTable();
  }
};

struct DesignInterfaceBuilder {
  typedef DesignInterface Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(DesignInterface::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DesignInterface::VT_NAME, name);
  }
  void add_type(SNL::FBS::DesignType type) {
    fbb_.AddElement<int8_t>(DesignInterface::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_terms_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> terms_type) {
    fbb_.AddOffset(DesignInterface::VT_TERMS_TYPE, terms_type);
  }
  void add_terms(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> terms) {
    fbb_.AddOffset(DesignInterface::VT_TERMS, terms);
  }
  explicit DesignInterfaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DesignInterface> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DesignInterface>(end);
    return o;
  }
};

inline flatbuffers::Offset<DesignInterface> CreateDesignInterface(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    SNL::FBS::DesignType type = SNL::FBS::DesignType_Standard,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> terms_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> terms = 0) {
  DesignInterfaceBuilder builder_(_fbb);
  builder_.add_terms(terms);
  builder_.add_terms_type(terms_type);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DesignInterface> CreateDesignInterfaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    SNL::FBS::DesignType type = SNL::FBS::DesignType_Standard,
    const std::vector<uint8_t> *terms_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *terms = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto terms_type__ = terms_type ? _fbb.CreateVector<uint8_t>(*terms_type) : 0;
  auto terms__ = terms ? _fbb.CreateVector<flatbuffers::Offset<void>>(*terms) : 0;
  return SNL::FBS::CreateDesignInterface(
      _fbb,
      id,
      name__,
      type,
      terms_type__,
      terms__);
}

struct DesignImplementation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DesignImplementationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Instance>> *instances() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Instance>> *>(VT_INSTANCES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCES) &&
           verifier.VerifyVector(instances()) &&
           verifier.VerifyVectorOfTables(instances()) &&
           verifier.EndTable();
  }
};

struct DesignImplementationBuilder {
  typedef DesignImplementation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instances(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Instance>>> instances) {
    fbb_.AddOffset(DesignImplementation::VT_INSTANCES, instances);
  }
  explicit DesignImplementationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DesignImplementation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DesignImplementation>(end);
    return o;
  }
};

inline flatbuffers::Offset<DesignImplementation> CreateDesignImplementation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Instance>>> instances = 0) {
  DesignImplementationBuilder builder_(_fbb);
  builder_.add_instances(instances);
  return builder_.Finish();
}

inline flatbuffers::Offset<DesignImplementation> CreateDesignImplementationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SNL::FBS::Instance>> *instances = nullptr) {
  auto instances__ = instances ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::Instance>>(*instances) : 0;
  return SNL::FBS::CreateDesignImplementation(
      _fbb,
      instances__);
}

struct Library FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LibraryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TYPE = 8,
    VT_LIBRARIES = 10,
    VT_DESIGN_INTERFACES = 12,
    VT_DESIGN_IMPLEMENTATIONS = 14
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  SNL::FBS::LibraryType type() const {
    return static_cast<SNL::FBS::LibraryType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>> *libraries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>> *>(VT_LIBRARIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignInterface>> *design_interfaces() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignInterface>> *>(VT_DESIGN_INTERFACES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignImplementation>> *design_implementations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignImplementation>> *>(VT_DESIGN_IMPLEMENTATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID, 2) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_LIBRARIES) &&
           verifier.VerifyVector(libraries()) &&
           verifier.VerifyVectorOfTables(libraries()) &&
           VerifyOffset(verifier, VT_DESIGN_INTERFACES) &&
           verifier.VerifyVector(design_interfaces()) &&
           verifier.VerifyVectorOfTables(design_interfaces()) &&
           VerifyOffset(verifier, VT_DESIGN_IMPLEMENTATIONS) &&
           verifier.VerifyVector(design_implementations()) &&
           verifier.VerifyVectorOfTables(design_implementations()) &&
           verifier.EndTable();
  }
};

struct LibraryBuilder {
  typedef Library Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(Library::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Library::VT_NAME, name);
  }
  void add_type(SNL::FBS::LibraryType type) {
    fbb_.AddElement<int8_t>(Library::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_libraries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>>> libraries) {
    fbb_.AddOffset(Library::VT_LIBRARIES, libraries);
  }
  void add_design_interfaces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignInterface>>> design_interfaces) {
    fbb_.AddOffset(Library::VT_DESIGN_INTERFACES, design_interfaces);
  }
  void add_design_implementations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignImplementation>>> design_implementations) {
    fbb_.AddOffset(Library::VT_DESIGN_IMPLEMENTATIONS, design_implementations);
  }
  explicit LibraryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Library> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Library>(end);
    return o;
  }
};

inline flatbuffers::Offset<Library> CreateLibrary(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    SNL::FBS::LibraryType type = SNL::FBS::LibraryType_Standard,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>>> libraries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignInterface>>> design_interfaces = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::DesignImplementation>>> design_implementations = 0) {
  LibraryBuilder builder_(_fbb);
  builder_.add_design_implementations(design_implementations);
  builder_.add_design_interfaces(design_interfaces);
  builder_.add_libraries(libraries);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Library> CreateLibraryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    const char *name = nullptr,
    SNL::FBS::LibraryType type = SNL::FBS::LibraryType_Standard,
    const std::vector<flatbuffers::Offset<SNL::FBS::Library>> *libraries = nullptr,
    const std::vector<flatbuffers::Offset<SNL::FBS::DesignInterface>> *design_interfaces = nullptr,
    const std::vector<flatbuffers::Offset<SNL::FBS::DesignImplementation>> *design_implementations = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto libraries__ = libraries ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::Library>>(*libraries) : 0;
  auto design_interfaces__ = design_interfaces ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::DesignInterface>>(*design_interfaces) : 0;
  auto design_implementations__ = design_implementations ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::DesignImplementation>>(*design_implementations) : 0;
  return SNL::FBS::CreateLibrary(
      _fbb,
      id,
      name__,
      type,
      libraries__,
      design_interfaces__,
      design_implementations__);
}

struct DB FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LIBRARIES = 6
  };
  int8_t id() const {
    return GetField<int8_t>(VT_ID, 1);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>> *libraries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>> *>(VT_LIBRARIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ID, 1) &&
           VerifyOffset(verifier, VT_LIBRARIES) &&
           verifier.VerifyVector(libraries()) &&
           verifier.VerifyVectorOfTables(libraries()) &&
           verifier.EndTable();
  }
};

struct DBBuilder {
  typedef DB Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int8_t id) {
    fbb_.AddElement<int8_t>(DB::VT_ID, id, 1);
  }
  void add_libraries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>>> libraries) {
    fbb_.AddOffset(DB::VT_LIBRARIES, libraries);
  }
  explicit DBBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DB>(end);
    return o;
  }
};

inline flatbuffers::Offset<DB> CreateDB(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t id = 1,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SNL::FBS::Library>>> libraries = 0) {
  DBBuilder builder_(_fbb);
  builder_.add_libraries(libraries);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DB> CreateDBDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t id = 1,
    const std::vector<flatbuffers::Offset<SNL::FBS::Library>> *libraries = nullptr) {
  auto libraries__ = libraries ? _fbb.CreateVector<flatbuffers::Offset<SNL::FBS::Library>>(*libraries) : 0;
  return SNL::FBS::CreateDB(
      _fbb,
      id,
      libraries__);
}

inline bool VerifyTerm(flatbuffers::Verifier &verifier, const void *obj, Term type) {
  switch (type) {
    case Term_NONE: {
      return true;
    }
    case Term_ScalarTerm: {
      auto ptr = reinterpret_cast<const SNL::FBS::ScalarTerm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Term_BusTerm: {
      auto ptr = reinterpret_cast<const SNL::FBS::BusTerm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTermVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTerm(
        verifier,  values->Get(i), types->GetEnum<Term>(i))) {
      return false;
    }
  }
  return true;
}

inline const SNL::FBS::DB *GetDB(const void *buf) {
  return flatbuffers::GetRoot<SNL::FBS::DB>(buf);
}

inline const SNL::FBS::DB *GetSizePrefixedDB(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SNL::FBS::DB>(buf);
}

inline bool VerifyDBBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SNL::FBS::DB>(nullptr);
}

inline bool VerifySizePrefixedDBBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SNL::FBS::DB>(nullptr);
}

inline void FinishDBBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SNL::FBS::DB> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDBBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SNL::FBS::DB> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace FBS
}  // namespace SNL

#endif  // FLATBUFFERS_GENERATED_SNL_SNL_FBS_H_
